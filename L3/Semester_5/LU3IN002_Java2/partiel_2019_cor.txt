/** QUESTION 1.1 a)Node **/

package pobj.micros.fs;

public class Node implements INode {
	
	private String name;
	
	@Override
	public String getName() { return name; }

	public Node(String name) {
		this.name = name;
	}
	
	public INode copy() { return new Node(name); }
}


/** QUESTION 1.1 b)FileNode **/

package pobj.micros.fs;

public class FileNode extends Node implements IFileNode {

	private byte[] data;
	
	public FileNode(String name, int length) {
		super(name);
		data = new byte[length];
	}
	
	@Override
	public int size() {
		return data.length;
	}

	@Override
	public int read(int pos) {
		if (pos >= 0  && pos < data.length) return data[pos];
		return 255;
	}

	@Override
	public void write(int pos, int c) {
		if (pos >= 0 && pos < data.length)
			data[pos] = (byte)c;
	}
	
	@Override
	public IFileNode copy() {
		FileNode n = new FileNode(getName(), data.length);
		for (int i = 0 ; i < data.length; i++)
			n.data[i] = data[i];
		return n;
	}

}


/** QUESTION 1.1 c)DirectoryNode **/

package pobj.micros.fs;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public class DirectoryNode extends Node implements IDirectoryNode {

	private Map<String, INode> dir = new HashMap<>();
	
	public DirectoryNode(String name) {
		super(name);
	}
	
	@Override
	public List<String> getChildren() {
		return new LinkedList<String>(dir.keySet());
	}

	@Override
	public INode getChild(String name) {
		return dir.get(name);
	}

	@Override
	public boolean addChild(INode node) {
		if (dir.containsKey(node.getName())) return false;
		dir.put(node.getName(), node);
		return true;
	}
	
	@Override
	public IDirectoryNode copy() {
		DirectoryNode d = new DirectoryNode(getName());
		for (Map.Entry<String, INode> e : dir.entrySet()) {
			d.dir.put(e.getKey(), e.getValue().copy());
		}
		return d;
	}
}


/** QUESTION 1.2 FileStream **/

package pobj.micros.fs;

public class FileStream implements IStream {

	private IFileNode data;
	private int pos;

	public FileStream(IFileNode data) {
		this.data = data;
	}
	
	@Override
	public int read() {
		if (pos >= data.size()) return 255;
		return data.read(pos++);
	}

	@Override
	public void write(int c) {
		if (pos < data.size()) {
			data.write(pos++,  c);
		}
	}

	@Override
	public void seek(int pos) {
		this.pos = pos;
	}

	@Override
	public int tell() {
		return pos;
	}

}


/** QUESTION 1.3 .copy() dans 1.1 a,b,c **/

a)
public INode copy() { return new Node(name); }

b)
public IFileNode copy() {
		FileNode n = new FileNode(getName(), data.length);
		for (int i = 0 ; i < data.length; i++)
			n.data[i] = data[i];
		return n;
	}

c)
@Override
	public IDirectoryNode copy() {
		DirectoryNode d = new DirectoryNode(getName());
		for (Map.Entry<String, INode> e : dir.entrySet()) {
			d.dir.put(e.getKey(), e.getValue().copy());
		}
		return d;
	}

/** QUESTION 1.4 a)NodeUtile **/

package pobj.micros.fs;

import pobj.micros.errors.OSError;

public class NodeUtils {
	
	public static IDirectoryNode findDirectory(IDirectoryNode root, String path) throws OSError {
		IDirectoryNode cur = root;
		String[] p = path.split("/");
		for (int i = 0; i < p.length; i++) {
			if (p[i].equals("")) continue;
			INode n = cur.getChild(p[i]);
			if (n == null || !(n instanceof IDirectoryNode))
				throw new OSError("invalid path");
			cur = (IDirectoryNode) n;
		}
		return cur;		
	}
}


/** QUESTION 1.4 b)FileSysytem **/

package pobj.micros.fs;

import java.util.List;

import pobj.micros.errors.OSError;

public class FileSystem implements IFileSystem {

	private IDirectoryNode root = new DirectoryNode("root");
	
	IDirectoryNode getRoot() {
		return root;
	}
	
	@Override
	public List<String> listDirectory(String path) throws OSError {
		return NodeUtils.findDirectory(getRoot(), path).getChildren();
	}

	@Override
	public void createDirectory(String path, String name) throws OSError {
		IDirectoryNode cur = NodeUtils.findDirectory(getRoot(), path);
		if (cur.getChild(name) != null)
			throw new OSError("invalid directory");
		cur.addChild(new DirectoryNode(name));
	}

	@Override
	public IFileNode openFile(String path,String name, int createSize) throws OSError {
		IDirectoryNode cur = NodeUtils.findDirectory(getRoot(), path);
		INode i = cur.getChild(name);
		if (i!=null) {
			if (!(i instanceof IFileNode))
				throw new OSError("invalid file");
			return (IFileNode) i;
		}
		else {
			IFileNode node = new FileNode(name, createSize);
			cur.addChild(node);
			return node;
		}
	}
	
}


/** QUESTION 2.1 a)FIFOStrategy et MostRecentStrategy  **/

FIFOStrategy)
package pobj.micros.scheduler;

import java.util.List;

public class FIFOStrategy implements IStrategy { 
	@Override
	public	ITask selectTask(List<ITask> tasks) {		
		return tasks.isEmpty() ? null : tasks.remove(tasks.size() - 1);
	}
}

MostRecentStrategy)
package pobj.micros.scheduler;

import java.util.List;

public class MostRecentStrategy implements IStrategy { 
	@Override
	public	ITask selectTask(List<ITask> tasks) {
		return tasks.isEmpty() ? null : tasks.remove(0);
	}
}


/** QUESTION 2.1 b)Scheduler **/

package pobj.micros.scheduler;

import java.util.LinkedList;
import java.util.List;

import pobj.micros.errors.OSError;

public class Scheduler implements IScheduler {

	private List<ITask> tasks = new LinkedList<ITask>();
	private IStrategy strategy;

	public Scheduler(IStrategy strategy) {
		this.strategy = strategy;
	}
		
	@Override
	public void postTask(ITask task) {
		tasks.add(0, task);
	}

	@Override
	public void setStrategy(IStrategy strategy) {
		this.strategy = strategy;
	}

	@Override
	public boolean execNext() throws OSError {
		ITask task = strategy.selectTask(tasks);
		if (task == null) return false;
		task.exec(this);
		return true;
	}
}


/** QUESTION 2.1 c)TaskRunner **/

package pobj.micros.scheduler;

import pobj.micros.errors.OSError;

public class TaskRunner {

	static public void run(IScheduler scheduler) {
		while (true) {
			try {
				if (!scheduler.execNext()) return;
			} catch (OSError e) {
				System.out.println(e.getMessage());
			}
		}
	}	

}


/** QUESTION 2.2 ExampleTask et ExampleMain**/

ExampleTask)
package pobj.micros.scheduler;

import pobj.micros.errors.OSError;

public class ExampleTask implements ITask {

	private int n;

	public ExampleTask(int n) {
		this.n = n;
	}

	@Override
	public void exec(IScheduler ctx) throws OSError {
		System.out.print(n);
		if (n > 0) {
			ITask t = new ExampleTask(n-1);
			ctx.postTask(t);
			ctx.postTask(t);
		}
	}

}

ExampleMain)
package pobj.micros.scheduler;

public class ExampleMain {
	
	public static void main(String[] args) {
		Scheduler sch = new Scheduler(new FIFOStrategy());
		sch.postTask(new ExampleTask(3));
		TaskRunner.run(sch);
	}

}


/** QUESTION 2.3 Service**/

package pobj.micros.scheduler;

public class Service implements IService {

	private  final String name;
	private final int version;
	
	public Service(String name, int version) {
		this.name = name;
		this.version = version;
	}
	
	@Override
	public String getName() {
		return name;
	}

	@Override
	public int getVersion() {
		return version;
	}

	@Override
	public String toString() {
		return getName() + "/" + getVersion();
	}
	
	@Override
	public boolean equals(Object x) {
		if (x instanceof IService) {
			IService y = (IService) x;
			return getName().equals(y.getName()) && version == y.getVersion();
		}
		else return false;
	}
	
	@Override
	public int hashCode() {
		return getName().hashCode() + getVersion();
	}
}


